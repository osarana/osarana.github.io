"""
ANN-A inference (switch-or-not) over your CSVs.

Usage:
  python models/infer_anna.py \
    --candidates data/candidates.csv \
    --snapshots data/snapshots.csv \
    --rag data/rag_features.csv \
    --model data/anna_gate.pt \
    --meta data/anna_gate_meta.json \
    --snapshot-id 123 \
    --device cuda

Notes:
- For the demo, we pick the "best" candidate using label_best_network from candidates.csv.
  In production, you'd use ANN-B to pick the best candidate, then pass deltas to ANN-A.
"""

import os, json, argparse
import numpy as np
import pandas as pd
import torch

from models.ann_a_gate import GateANNA


BASE_DELTA_COLS = [
    "tput_dl_mbps", "rtt_ms", "jitter_ms", "loss_rate",
    "p_denial", "energy_mwh_per_mb", "cost_per_mb",
]
RAG_DELTA_COLS = [
    "knn_tput_p50", "knn_tput_p90", "knn_rtt_p90", "knn_loss_mean", "knn_p_denial_mean"
]
EXTRA_SCALARS = ["switch_outage_ms"]


def load_anna(model_path, meta_path, device):
    meta = json.load(open(meta_path))
    model = GateANNA(in_dim=len(meta["feature_cols"]))
    state = torch.load(model_path, map_location="cpu")
    model.load_state_dict(state)
    model.to(device).eval()
    return model, meta


def features_for_snapshot(snapshot_id: int, cand_df: pd.DataFrame, rag_df: pd.DataFrame | None):
    # rows for this snapshot
    g = cand_df[cand_df.snapshot_id == snapshot_id]
    if g.empty:
        raise ValueError(f"No candidates for snapshot_id={snapshot_id}")

    # choose BEST using ground-truth label (for demo)
    if "label_best_network" not in g.columns:
        # compute best if missing
        g_av = g[g["available"] == 1]
        if g_av.empty:
            # fallback: pick current row as best
            best = g[g["candidate_network"] == g["current_network"].iloc[0]].iloc[0]
        else:
            idx = g_av["net_utility"].astype(float).idxmax()
            best = g.loc[idx]
    else:
        best = g[g.candidate_network == g.label_best_network.iloc[0]].iloc[0]

    cur = g[g.candidate_network == g.current_network.iloc[0]].iloc[0]

    # base deltas
    feat = {}
    for col in BASE_DELTA_COLS:
        feat[f"delta_{col}"] = float(best[col]) - float(cur[col])

    # extra scalars (from best row)
    for col in EXTRA_SCALARS:
        feat[col] = float(best[col])

    # optional RAG deltas
    if rag_df is not None and not rag_df.empty:
        rb = rag_df[(rag_df.snapshot_id == snapshot_id) & (rag_df.candidate_network == best.candidate_network)]
        rc = rag_df[(rag_df.snapshot_id == snapshot_id) & (rag_df.candidate_network == cur.candidate_network)]
        if not rb.empty and not rc.empty:
            rb, rc = rb.iloc[0], rc.iloc[0]
            for col in RAG_DELTA_COLS:
                feat[f"delta_{col}"] = float(rb[col]) - float(rc[col])
        else:
            # fill missing RAG deltas with 0.0
            for col in RAG_DELTA_COLS:
                feat[f"delta_{col}"] = 0.0

    return feat, best["candidate_network"], cur["candidate_network"]


def to_tensor(feat_dict: dict, meta: dict, device):
    cols = meta["feature_cols"]
    mean = np.array(meta["mean"], dtype=np.float32)
    std  = np.array(meta["std"], dtype=np.float32)
    x = np.array([feat_dict.get(c, 0.0) for c in cols], dtype=np.float32)
    x = (x - mean) / (std + 1e-6)
    xt = torch.from_numpy(x[None, :]).to(device)
    return xt


def decide(prob: float, threshold: float):
    return "SWITCH" if prob >= threshold else "STAY"


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--candidates", default="data/candidates.csv")
    ap.add_argument("--snapshots", default="data/snapshots.csv")  # not used; kept for symmetry
    ap.add_argument("--rag", default="data/rag_features.csv")
    ap.add_argument("--model", default="data/anna_gate.pt")
    ap.add_argument("--meta", default="data/anna_gate_meta.json")
    ap.add_argument("--snapshot-id", type=int, required=True)
    ap.add_argument("--device", default="cuda", choices=["cuda","cpu"])
    args = ap.parse_args()

    device = torch.device(args.device if (args.device == "cuda" and torch.cuda.is_available()) else "cpu")
    print("Device:", device)

    cand_df = pd.read_csv(args.candidates)
    rag_df = pd.read_csv(args.rag) if os.path.exists(args.rag) else None

    model, meta = load_anna(args.model, args.meta, device)
    xt_feats, best_net, cur_net = features_for_snapshot(args.snapshot_id, cand_df, rag_df)
    xt = to_tensor(xt_feats, meta, device)

    with torch.no_grad():
        logit = model(xt).item()
        prob = 1.0 / (1.0 + np.exp(-logit))

    thresh = float(meta.get("threshold", 0.5))
    action = decide(prob, thresh)

    print("\n=== ANN-A inference ===")
    print(f"snapshot_id         : {args.snapshot_id}")
    print(f"current_network     : {cur_net}")
    print(f"best_candidate(label): {best_net}  (for demo; ANN-B would pick this)")
    print(f"P(switch_now)       : {prob:.4f}  (threshold={thresh})")
    print(f"decision            : {action}")

    # Show a few input deltas for transparency
    show = {k: v for k, v in xt_feats.items() if k in ["delta_tput_dl_mbps","delta_rtt_ms","delta_loss_rate","switch_outage_ms"]}
    print("\nfeature preview:", show)

if __name__ == "__main__":
    main()
